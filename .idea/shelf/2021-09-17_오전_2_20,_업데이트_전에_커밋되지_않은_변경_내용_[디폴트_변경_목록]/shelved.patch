Index: app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nfrom pymongo import MongoClient\r\nfrom bson.objectid import ObjectId\r\n\r\nimport jwt\r\nimport datetime\r\nimport hashlib\r\nfrom flask import Flask, render_template, jsonify, request, redirect, url_for\r\nfrom werkzeug.utils import secure_filename\r\nfrom datetime import datetime, timedelta\r\nfrom decouple import config\r\n\r\n\r\nSECRET_KEY = config('SECRET_KEY')\r\nIP = config('IP')\r\nPORT = config('DB_PORT')\r\n\r\napp = Flask(__name__)\r\napp.config[\"TEMPLATES_AUTO_RELOAD\"] = True\r\napp.config['UPLOAD_FOLDER'] = \"./static/profile_pics\"\r\n\r\nSECRET_KEY = SECRET_KEY\r\nclient = MongoClient(IP, int(PORT))\r\nDBNAME = client.dbsparta_plus_week4\r\ndb = client.dbsparta_plus_week4\r\n\r\n@app.route('/')\r\ndef home():\r\n    token_receive = request.cookies.get('mytoken')\r\n    if token_receive is None:\r\n        return redirect(url_for(\"login\"))\r\n\r\n    food_receive = request.args.get(\"food_give\")\r\n    user = list(db.users.find({}))\r\n    for item in user:\r\n        item[\"_id\"] = str(item[\"_id\"])\r\n    random_user = random.sample(user, 3)\r\n    try:\r\n        payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\r\n        user_info = db.users.find_one({\"username\": payload[\"id\"]})\r\n        if food_receive == None:\r\n            # 최근순으로 작성되어지는 포스트 솔팅해서 구현.\r\n            posts = list(db.posts.find({}))\r\n            return render_template(\"index.html\", list=posts, rec_user=random_user, user_info=user_info)\r\n        else:\r\n            # 최근순으로 작성되어지는 포스트 솔팅하기.\r\n            search_result = list(db.posts.find({'post_title': food_receive}))\r\n\r\n            return render_template(\"index.html\", list=search_result, rec_user=random_user, user_info=user_info)\r\n    except jwt.ExpiredSignatureError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 시간이 만료되었습니다.\"))\r\n    except jwt.exceptions.DecodeError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 정보가 존재하지 않습니다.\"))\r\n\r\n\r\n@app.route('/login')\r\ndef login():\r\n    token_receive = request.cookies.get('mytoken')\r\n    msg = request.args.get(\"msg\")\r\n    if token_receive is not None and msg is None:\r\n        return redirect(url_for(\"home\"))\r\n    else:\r\n        return render_template('login.html', msg=msg)\r\n\r\n@app.route('/sign_in', methods=['POST'])\r\ndef sign_in():\r\n    username_receive = request.form['username_give']\r\n    password_receive = request.form['password_give']\r\n\r\n    pw_hash = hashlib.sha256(password_receive.encode('utf-8')).hexdigest()\r\n    result = db.users.find_one({'username': username_receive, 'password': pw_hash})\r\n\r\n    if result is not None:\r\n        payload = {\r\n         'id': username_receive,\r\n         'exp': datetime.utcnow() + timedelta(seconds=60 * 60 * 24)  # 로그인 24시간 유지\r\n        }\r\n        token = jwt.encode(payload, SECRET_KEY, algorithm='HS256')\r\n\r\n        return jsonify({'result': 'success', 'token': token})\r\n    else:\r\n        return jsonify({'result': 'fail', 'msg': '아이디/비밀번호가 일치하지 않습니다.'})\r\n\r\n\r\n@app.route('/sign_up/save', methods=['POST'])\r\ndef sign_up():\r\n    username_receive = request.form['username_give']\r\n    password_receive = request.form['password_give']\r\n    password_hash = hashlib.sha256(password_receive.encode('utf-8')).hexdigest()\r\n    profile_receive = request.form['profile_name_receive']\r\n    doc = {\r\n        \"username\": username_receive,\r\n        \"password\": password_hash,\r\n        \"profile_name\": profile_receive,\r\n        \"profile_pic\": \"\",\r\n        \"profile_pic_real\": \"profile_pics/profile_placeholder.png\",\r\n        \"profile_info\": \"\"\r\n    }\r\n    db.users.insert_one(doc)\r\n    return jsonify({'result': 'success'})\r\n\r\n\r\n@app.route('/sign_up/check_dup', methods=['POST'])\r\ndef check_dup():\r\n    username_receive = request.form['username_give']\r\n    exists = bool(db.users.find_one({\"username\": username_receive}))\r\n    return jsonify({'result': 'success', 'exists': exists})\r\n\r\n\r\n@app.route('/new', methods=['POST'])\r\ndef add_post():\r\n    token_receive = request.cookies.get('mytoken')\r\n    try:\r\n        payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\r\n\r\n        username = payload[\"id\"]\r\n        user_info = db.users.find_one({'username': username}, {\"_id\": False})\r\n\r\n        post_title = request.form['title_give']\r\n        post_day = request.form['day_give']\r\n        post_comment = request.form['comment_give']\r\n\r\n        new_doc = {\r\n            \"username\": user_info['username'],\r\n            \"profile_name\": user_info['profile_name'],\r\n            \"profile_pic_real\": user_info['profile_pic_real'],\r\n            \"post_title\": post_title,\r\n            \"post_day\": post_day,\r\n            \"post_comment\": post_comment\r\n        }\r\n\r\n        if 'file_give' in request.files:\r\n            file = request.files[\"file_give\"]\r\n            filename = secure_filename(file.filename)\r\n            extension = filename.split(\".\")[-1]\r\n            file_path = f\"post_pics/{username}_{post_day}_{str(datetime.utcnow())}.{extension}\"\r\n            # file_path = f\"post_pics/{username}_{post_day}.{extension}\"\r\n            file.save(\"./static/\" + file_path)\r\n\r\n            new_doc[\"post_pic\"] = filename\r\n            new_doc[\"post_pic_real\"] = file_path\r\n\r\n        db.posts.insert_one(new_doc)\r\n        return jsonify({\"result\": \"success\", 'msg': '프로필을 업데이트했습니다.'})\r\n    except jwt.ExpiredSignatureError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 시간이 만료되었습니다.\"))\r\n    except jwt.exceptions.DecodeError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 정보가 존재하지 않습니다.\"))\r\n\r\n@app.route('/user/<username>')\r\ndef user(username):\r\n    token_receive = request.cookies.get('mytoken')\r\n    try:\r\n        payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\r\n        status = (username == payload[\"id\"])\r\n        user_info = db.users.find_one({\"username\": username}, {\"_id\": False})\r\n        posts_info = list(db.posts.find({\"username\": username}).sort(\"date\", -1).limit(20))\r\n        for post in posts_info:\r\n            print(str(post[\"_id\"]))\r\n            post[\"_id\"] = str(post[\"_id\"])\r\n\r\n        return render_template('user.html', user_info=user_info, status=status, posts_info=posts_info)\r\n    except jwt.ExpiredSignatureError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 시간이 만료되었습니다.\"))\r\n    except jwt.exceptions.DecodeError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 정보가 존재하지 않습니다.\"))\r\n\r\n\r\n@app.route('/user/<username>', methods=['PATCH'])\r\ndef update_user(username):\r\n    token_receive = request.cookies.get('mytoken')\r\n    try:\r\n        payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\r\n        if payload['id'] == username:\r\n            new_doc = {}\r\n            nick_receive = request.form['nick_give']\r\n            if nick_receive: new_doc['profile_name'] = nick_receive\r\n\r\n            if 'file_give' in request.files:\r\n                file = request.files[\"file_give\"]\r\n                filename = secure_filename(file.filename)\r\n                extension = filename.split(\".\")[-1]\r\n\r\n                file_path = f\"profile_pics/{username}.{extension}\"\r\n                file.save(\"./static/\" + file_path)\r\n\r\n                new_doc[\"profile_pic\"] = filename\r\n                new_doc[\"profile_pic_real\"] = file_path\r\n\r\n            db.users.update_one({'username': username}, {'$set': new_doc})\r\n            return jsonify({'result': 'success', 'msg': '정상적으로 수정이 완료되었습니다!'}), 200\r\n        else:\r\n            return jsonify({'result': 'failure'}), 403\r\n    except jwt.ExpiredSignatureError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 시간이 만료되었습니다.\"))\r\n    except jwt.exceptions.DecodeError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 정보가 존재하지 않습니다.\"))\r\n\r\n@app.route('/user/<username>', methods=['DELETE'])\r\ndef delete_user(username):\r\n    token_receive = request.cookies.get('mytoken')\r\n    try:\r\n        payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\r\n        if payload['id'] == username:\r\n            db.users.delete_one({'username': username})\r\n            db.posts.delete_many({'username': username})\r\n\r\n            return jsonify({'result': 'success', 'message': '그동안 저희 서비스를 이용해주셔서 감사했습니다'})\r\n        else:\r\n            return jsonify({'result': 'failure', 'message': '올르지 않은 접근입니다'}), 403\r\n    except jwt.ExpiredSignatureError:\r\n            return redirect(url_for(\"login\", msg=\"로그인 시간이 만료되었습니다.\"))\r\n    except jwt.exceptions.DecodeError:\r\n        return redirect(url_for(\"login\", msg=\"로그인 정보가 존재하지 않습니다.\"))\r\n\r\n\r\n@app.route('/p/<post_id>', methods=['GET'])\r\ndef get_post_detail(post_id):\r\n    token_receive = request.cookies.get('mytoken')\r\n    post = db.posts.find_one({'_id': ObjectId(post_id)}, {'_id': False})\r\n    try:\r\n        payload = jwt.decode(token_receive, SECRET_KEY, algorithms=['HS256'])\r\n        is_valid_user = True if (post['username'] == payload['id']) else False\r\n        user = db.users.find_one({'username': payload['id']}, {'_id': False})\r\n        return jsonify({\r\n            'user': user,\r\n            'post': post,\r\n            'status': is_valid_user\r\n        })\r\n    except jwt.ExpiredSignatureError:\r\n            return redirect(url_for(\"login\", msg=\"로그인 시간이 만료되었습니다.\"))\r\n    except jwt.exceptions.DecodeError:\r\n            return redirect(url_for(\"login\", msg=\"로그인 정보가 존재하지 않습니다.\"))\r\n\r\n\r\nif __name__ == '__main__':\r\n   app.run('0.0.0.0', port=5000, debug=True)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.py b/app.py
--- a/app.py	(revision 927eb4455ca185bc741fa299a00c2ecaecd7683d)
+++ b/app.py	(date 1631805460144)
@@ -133,8 +133,8 @@
             file = request.files["file_give"]
             filename = secure_filename(file.filename)
             extension = filename.split(".")[-1]
-            file_path = f"post_pics/{username}_{post_day}_{str(datetime.utcnow())}.{extension}"
-            # file_path = f"post_pics/{username}_{post_day}.{extension}"
+            #file_path = f"post_pics/{username}_{post_day}_{str(datetime.utcnow())}.{extension}"
+            file_path = f"post_pics/{username}_{post_day}.{extension}"
             file.save("./static/" + file_path)
 
             new_doc["post_pic"] = filename
